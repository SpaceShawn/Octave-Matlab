%#!/usr/bin/octave -qf --traditional
%# this is the bonus assignment
%# SB_ namespace for user defined functions

%#arg_list = argv ();

%#num = str2int(arg_list{1});
%#fprintf ('' . program_name () . ' You entered: ' . num);

%# defines
format long;
global a=0;
global b=0;
global x=0;
global y=0;
global L; 
L=12;%# L = input('Enter a number to represent the beam length in metres: ');
global P;
P=100000;%#P = input('Enter a number to represent the force to place on the beam: ');
global result = 1; %# initialize to allow execution;

function [result] = Simpsons38 (Fun,a,b)
	global result;
	result = 1;
	fprintf('\r\nstarting execution of S38\r\n');
    fprintf('Range of evaluation [%f,%f]',a,b);
    i = 3; %# Simpsons rule should only be evaluated with even subintervals!
	fprintf('Subintervals: %d\r\n', i);
    if (mod(i,2)>0)
        fprintf ('S38 method must be evaluated with even subintervals! %d is not a valid number of intervals!\r\n');
    endif;

    %# execute Simpson's loop if the number of intervals is even and difference not less than 0.1
    do
	i = i * 2; %# double the interval count
	points = i+1;
	iteration_title = strcat('Simspon 3/8:', int2str(i), ' intervals');
	result_matrix = size(points,2);

	fprintf('\r\nSubintervals: %d\r\n', i);
	fprintf('Points: %d\r\n', points);
        h = (a+b)/i; %# calculate the interval width
	fprintf('Interval width: %f\r\n', h);

	%# evaluate first term
	fprintf('>>Calculating first_term\r\n');
	first_term = Fun(a);
	result_matrix(1,(a/h+1)) = [a]; %# store x value
	result_matrix(2,(a/h+1)) = [first_term]; %# store y value

        %# first sum will be evaluated for 2,3, 5,6, 8,9, 11,12 etc.
        %# first sum will be multiplied by 3
        first_sum = 0; %#initialize
        %# skip to the second term
        j = a + h;
	interval = 1;
	fprintf('>>Calculating first_sum\r\n');
        while (j<(b-h))
       	     	l = j;
		k = j + h; %# term for the second evaluation, Fun(k)
		j_term = Fun(j);
		result_matrix(1,(j/h+1)) = [j]; %# store x value
		result_matrix(2,(j/h+1)) = [j_term]; %# store y value
		k_term = Fun(k);
		result_matrix(1,(k/h+1)) = [k]; %# store x value
		result_matrix(2,(k/h+1)) = [k_term]; %# store y value
		first_sum = first_sum + j_term + k_term;
		j = l + (h*3); %# increment for the next loop
        endwhile;

        %# second sum will be evaluated for 4,7,10,13, etc.
        %# second sum will be multiplied by 2
        second_sum = 0; %# initialize

        %# skip to the fourth term
        j = a + h + h + h;
		fprintf('>>Calculating second_sum\r\n');
        while (j < (b-h))			
		j_term = Fun(j);
		result_matrix(1,(j/h+1)) = [j]; %# store x value
		result_matrix(2,(j/h+1)) = [j_term]; %# store y value
        	second_sum = second_sum + j_term;
	        j = j + (h*3);
        endwhile;

	%# evaluate last term
	fprintf('>>Calculating last term\r\n');
	last_term = Fun(b);
	result_matrix(1,(b/h+1)) = [b]; %# store x value
	result_matrix(2,(b/h+1)) = [last_term]; %# store y value

        %# save old Simpson sum
        old_result = result;

        %# add up all the results for new result
        result = (3*h/8)*(first_term + 3*first_sum + 2*second_sum + last_term);

        %# calculate the difference between the last Simpson sum
        SimpsonDifference = old_result - result;
	fprintf('Simpson Difference:%e\r\n',SimpsonDifference);
	fprintf([repmat('%e\t', 1, size(result_matrix, 2)) '\n'], result_matrix');
	x = a:h:b;
	plot (x,result_matrix(2,:));
	legend(iteration_title);
	hold on;
    until (SimpsonDifference <= 0.1);	
    fprintf('\r\nHit exit condition\r\n\r\n');
endfunction;

%# function for cross-sectional area of a beam
function [area] = SB_crossSectionalArea(x,L)
	R = 50; 
    	r = 20; 	
	area = pi * ( R - (R-r)/L * x )^2;
	fprintf('SB_crossSectionalArea() x=%f R=%f r=%f L=%f Area=%f \r\n',x,R,r,L,area);
endfunction;
%# test this function
%# SB_crossSectionalArea(3,100);

%# function for the normal strain in a beam
%# P : force applied
%# E : Modulus of Elasticity, 70 GPa
%# A : Cross-sectional area of the beam
function [normal_strain] = SB_normalStrain(P,A)
	E = 70*10^9;
	normal_strain = P / ( E * A );
endfunction;
%# test this function
SB_normalStrain(20,7000);

%# function to calculate the displacement of a point x = x_p along the beam
function [displacement] = SB_pointDisplacement(x_p)
    	global P;
	global L;
	A = SB_crossSectionalArea(x_p,L);
	E = 70000000000;
	displacement = SB_normalStrain(P,A);
	fprintf('SB_pointDisplacement()  x=%f P=%f A=%f E=%e displacement=%e \r\n',x_p,P,A,E,displacement);
endfunction;
%# test this function 
%# SB_pointDisplacement(10);

%# evaluate user-defined Simpsons38 function 
Simpsons38( @SB_pointDisplacement, 0,L);

%# calculate the displacement with QUAD
%# QUAD(blah);
%# plot the calculated displacement as a function of x
%# plot(x, y); legend('label')
